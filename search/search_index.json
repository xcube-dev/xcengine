{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"xcengine","text":"<p>xcengine turns Python Jupyter notebooks into:</p> <ul> <li>OGC Earth Observation Application   Packages</li> <li>Run-anywhere Docker images that bundle datasets with an   xcube server/viewer deployment   for easy interfacing and visualization</li> </ul> <p>Earth Observation Application Packages can be complex to implement correctly. The process can't be completely automated, but xcengine tries to simplify it as much as possible for Jupyter Notebook authors using code analysis and sensible defaults.</p> <p>This documentation provides instructions for installing and using xcengine and links to further resources.</p> <ol> <li>Introduction</li> <li>Installing xcengine</li> <li>Making a Jupyter notebook xcengine-compatible</li> <li>Running <code>xcetool</code></li> <li>Testing and running Application Packages</li> <li>Further documentation and resources</li> </ol> <p>xcengine is developed as part of the Open Earth Monitor Cyberinfrastructure project, which has received funding from the European Union's Horizon Europe research and innovation programme under grant agreement No. 101059548.</p>"},{"location":"installing/","title":"Installing xcengine","text":"<p>xcengine is developed on GitHub and distributed as a Conda package on the conda-forge channel.</p>"},{"location":"installing/#installing-from-conda-forge","title":"Installing from conda-forge","text":"<p>Using mamba, conda, or any other conda-compatible package manager, you can install xcengine into the current environment with a command like</p> <pre><code>mamba install -c conda-forge xcengine\n</code></pre> <p>You can create a new environment containing xcengine with a command like</p> <pre><code>mamba create -c conda-forge xcengine\n</code></pre>"},{"location":"installing/#installing-directly-from-the-github-repository","title":"Installing directly from the GitHub repository","text":"<p>If you want to work with the latest, unreleased development version of xcengine, you can install it from the GitHub repository.</p> <p>First, clone the repository and change to its root directory:</p> <pre><code>git clone https://github.com/xcube-dev/xcengine.git\ncd xcengine\n</code></pre> <p>Next, create a conda environment containing the dependencies and activate it:</p> <pre><code>mamba env create -f environment.yml\nmamba activate xcengine\n</code></pre> <p>Finally, install xcengine itself from the repository using pip:</p> <pre><code>pip install --no-deps --editable .\n</code></pre>"},{"location":"intro/","title":"Introduction","text":"<p>xcengine turns Python Jupyter notebooks into Earth Observation Application Packages and Docker images bundling an xcube Server and Viewer.</p>"},{"location":"intro/#jupyter-notebooks","title":"Jupyter notebooks","text":"<p>Jupyter notebooks provide a web-based interactive development environment which integrates code, documentation, and output visualization.</p>"},{"location":"intro/#application-packages","title":"Application packages","text":"<p>The Earth Observation Application Package is an increasingly popular format for packaging and deploying EO software tools. It is defined in a Best Practice document published by the Open Geospatial Consortium. An Application Package consists of two parts:</p> <ol> <li>A Docker container     image    containing the processing code to be packaged.</li> <li>A Common Workflow Language (CWL) file    which defines how the code in the container image should be run,    and what its available parameters, inputs, and outputs are.</li> </ol> <p>Application Packages are designed to be run on cloud processing platforms, but can also be tested locally. Application Packages provide a great deal of power and flexibility; partly because of this flexibility, they can be complex and challenging to build from scratch.</p>"},{"location":"intro/#xcube-server-and-viewer","title":"xcube Server and Viewer","text":"<p>xcube is a mature and powerful Python framework for EO data processing and visualization. Amongst other features, it includes an API server and web viewer which can serve and visualize data from a wide variety of sources, both statically stored and fetched or processed on demand.</p>"},{"location":"intro/#xcengine","title":"xcengine","text":"<p>xcengine takes Python Jupyter notebooks as input, and produces a Docker image and a CWL file which encapsulate the code contained in the notebook. Together these constitute an Application Package. The Docker image can also be run in an interactive, stand-alone mode to start up an xcube API server and web viewer, allowing the notebook's data to be exported via a variety of standard interfaces or explored visually and interactively.</p>"},{"location":"notebook/","title":"Making a Jupyter notebook xcengine-compatible","text":"<p>xcengine is designed to require as little alteration as possible to a Python notebook, but some configuration may be necessary, in particular to define input parameters.</p>"},{"location":"notebook/#configuring-input-parameters","title":"Configuring input parameters","text":"<p>An Application Package can have, and usually does have, input parameters defined types and default values, which can be set by the caller when running the package. xcengine automatically generates these parameters from variables in the notebook. Any variable to be used as a parameter must be defined in the parameters cell of the notebook. You can only have one parameters cell in a notebook, and it is strongly advised that the parameters cell appear as early as possible in the notebook.</p> <p>You turn a normal code cell into a parameters cell by adding a tag called parameters to it in Jupyter Lab using the Property Inspector. (The Property Inspector can be opened by clicking the gear icon at the top right of the Jupyter Lab window.)</p> <p></p> <p>You can define as many parameters as you like in the property cell. The values you assign to them will be used as the default values for these parameters when xcengine generates the Application Package.</p> <p>This tagging convention is similar to the one used by papermill.</p>"},{"location":"notebook/#configuring-xcengine","title":"Configuring xcengine","text":"<p>As well as parameters, the parameters cell can contain an xcengine configuration dictionary. This is a Python dictionary with the special name <code>xcengine_config</code>. Available configuration settings are:</p> <ul> <li><code>workflow_id</code>: a string identifier for the workflow in your Application     Package. The runner or Application Package platform can use this     identifier to refer to you Application Package. By default, the name     of the notebook (without the <code>.ipynb</code> suffix) is used.</li> <li><code>environment_file</code>: the name of a YAML file defining a conda     environment     (these are often called <code>environment.yml</code>). If an environment file is not     specified in the notebook or on the command line, xcetool will try to     deduce the environment automatically. This cannot be done 100% reliably,     so it is strongly recommended to provide an environment file.</li> <li><code>container_image_tag</code>: the tag applied to the Docker container image that     xcengine builds. If you plan to push the image to a public registry,     you can enter the final registry tag here and push the image once it's     been built by xcengine. If no tag is specified, xcengine will create one     based on the current date and time.</li> </ul> <p>Some of these configuration settings can also be set on the command line.</p>"},{"location":"notebook/#dataset-output","title":"Dataset output","text":""},{"location":"notebook/#selecting-datasets-for-output","title":"Selecting datasets for output","text":"<p>No additional code or configuration is needed for datasets to be written from Application Packages or served when the container image is run in xcube Server/Viewer mode. xcengine will automatically output or serve any instance of <code>xarray.DataSet</code> which is in scope when the notebook's code has finished executing. If you're created some datasets which you don't wish to be written, you can use the Python <code>del</code> statement to delete them at the end of the notebook to remove them, e.g.</p> <pre><code>del my_temporary_dataset\n</code></pre>"},{"location":"notebook/#setting-dataset-output-type","title":"Setting dataset output type","text":"<p>By default, all <code>xarray.DataSet</code> instances are written as Zarr. But you can force them to be written as NetCDF by setting an attribute on the dataset, like this:</p> <pre><code>my_dataset.attrs[\"xcengine_output_format\"] = \"netcdf\"\n</code></pre>"},{"location":"resources/","title":"Further documentation and resources","text":"<p>xcengine has been presented at several conferences and workshops. Most of the presentation materials are available online and provide a useful complement to this documentation.</p> <ul> <li> <p>Presentation at OEMC Global Workshop 2024, Laxenburg. Pontus Lurcock, \"Large-scale EO processing with xcube on CDSE\".  Video recording of presentation.</p> </li> <li> <p>Presentation at ESA Living Planet Symposium 2025, Vienna. Pontus Lurcock, Tejas Morbagal Harish, and Alicja Balfanz, \"From notebooks to application packages with xcube and xcengine\". Slide deck.</p> </li> <li> <p>Tutorial at OpenGeoHub EO-Council Summer School 2025, Wageningen: \"Application packages in the xcube ecosystem\". Course page with links to slides, documentation, and hands-on exercises. Video recording of presentation.</p> </li> <li> <p>Presentation at ESA Big Data from Space 2025, Riga. Yogesh Baljeet Singh, Norman Fomferra, Pontus Lurcock, Gunnar Brandt and Tejas Morbagal Harish: \"From reproducible EO Workflow development to OGC Application Packages for Scalable Data Cube Generation and Visualisation\". Programme entry.</p> </li> </ul>"},{"location":"running-eoaps/","title":"Testing and running Application Packages","text":"<p>Application Packages are generally deployed to cloud platforms, but there are also ways to run CWL files and complete Application Packages locally.</p>"},{"location":"running-eoaps/#understanding-and-debugging-xcengine-container-images","title":"Understanding and debugging xcengine container images","text":""},{"location":"running-eoaps/#the-base-image","title":"The base image","text":"<p>When generating a container image, xcengine uses a micromamba image as a base. If you need to investigate or debug an xcengine image, or if you're just curious about its structure, you may find the micromamba-docker documentation useful.</p>"},{"location":"running-eoaps/#entry-points","title":"Entry points","text":"<p>xcengine sets a custom entry point to run its own runner script, so any commands provided when running a container from an xcengine image with <code>docker run</code> will be applied as arguments to the xcengine runner. For instance, for an image tagged <code>myimage:1</code>, the <code>--server</code> parameter can be used like this:</p> <p><code>docker run myimage:1 --server</code></p> <p>This would run the xcengine runner script with the <code>--server</code> option, which starts an xcube server and viewer instance.</p> <p>To explore or debug a container image, it's often useful to start a container with an interactive shell. To do this with an xcengine image, it's not enough to provide a path to a shell as a command, since this path will just be passed as a parameter to the xcengine runner script. You need to set the entry point as well, like this:</p> <p><code>docker run --rm -it --entrypoint /usr/local/bin/_entrypoint.sh myimage:1 bash</code></p> <p>This resets the entry point to the usual micromamba-docker entry point, which sets up the Python environment, then runs bash within that environment.</p>"},{"location":"running-eoaps/#the-dockerfile-and-environment-file","title":"The Dockerfile and environment file","text":"<p>To aid reproducibility, the Dockerfile and environment file used to set up the container image are both included in the image itself, in the <code>/tmp</code> directory. The rest of the code and configuration for the image is in the <code>/home/mambauser</code> directory. In combination with the publicly available micromamba base image, each xcengine image thus contains the resources necessary to reproduce its own build process.</p>"},{"location":"running-eoaps/#running-with-cwltool","title":"Running with cwltool","text":"<p>cwltool is the reference runner for CWL files. It doesn't implement the full Application Package best practice (so there is no stage-in / stage-out functionality) but can nevertheless be used to run CWL files that implement Application Packages.</p>"},{"location":"running-eoaps/#running-with-zoo-project-and-the-dru-extensions","title":"Running with ZOO-Project and the DRU extensions","text":"<p>For a fully functional, locally deployable Application Package platform you can use the ZOO-Project with the optional DRU extensions, running on minikube. The EOEPCA+ documentation gives detailed instructions for installation.</p>"},{"location":"running-eoaps/#deploying-your-application-package-to-a-platform","title":"Deploying your Application Package to a platform","text":"<p>Once your container image has been pushed to a registry, the CWL file can be deployed to a cloud platform to make your Application Package available to users of this platform. The process for deploying the CWL file varies; consult the platform documentation or support for details.</p>"},{"location":"xcetool/","title":"Running xcengine","text":""},{"location":"xcetool/#the-xcetool-command","title":"The <code>xcetool</code> command","text":"<p>The command-line interface to xcengine is the command <code>xcetool</code>, which implements multiple subcommands and options for building and running container images and Application Packages.</p> <p>You can use the <code>--help</code> flag for any <code>xcetool</code> command or subcommand to get more details on usage and available options.</p>"},{"location":"xcetool/#xcetool-image-build","title":"<code>xcetool image build</code>","text":"<p>Usage: <code>xcetool image build [OPTIONS] NOTEBOOK</code></p> <p>This is the main <code>xcetool</code> subcommand: it builds a container image from a supplied notebook and environment file. If given the <code>--eoap</code> argument, it also generates a CWL file defining a corresponding application package.</p> <p>Options:</p> <ul> <li><code>-b</code>, <code>--build-dir</code> <code>DIRECTORY</code>: Build directory to use for preparing the     Docker image. If not specified, an automatically created temporary     directory will be used.     This option is mainly useful for debugging.</li> <li><code>-e</code>, <code>--environment</code> <code>FILE</code>:     Conda environment file to use in Docker image.     If no environment file is specified here or in the notebook,     xcetool will look for a file called <code>environment.yml</code>     in the notebook's directory. If all else fails,     xcetool will try to reproduce the current environment     as a last resort, but this is not guaranteed to succeed.</li> <li><code>-t</code>, <code>--tag</code> <code>TEXT</code>: Tag to apply to the Docker image.     If not specified, a     timestamp-based tag will be generated automatically.</li> <li><code>-a</code>, <code>--eoap</code> <code>PATH</code>: Write a CWL file defining an Earth Observation     Application Package to the specified path.</li> <li><code>--help</code>: Show a help message for this subcommand and exit.</li> </ul>"},{"location":"xcetool/#xcetool-image-run","title":"<code>xcetool image run</code>","text":"<p>Usage: <code>xcetool image run [OPTIONS] IMAGE [CONTAINER_ARGUMENT]...</code></p> <p>Options:</p> <ul> <li><code>-b</code>, <code>--batch</code>: Run the compute engine as a batch script.     Use with the <code>--output</code> option to copy output     out of the container.</li> <li><code>-s</code>, <code>--server</code>: Run the compute engine as an xcube server.</li> <li><code>-p</code>, <code>--port</code> INTEGER: Host port for xcube server (default: 8080).     Implies <code>--server</code>.</li> <li><code>-f</code>, <code>--from-saved</code>: If <code>--batch</code> and <code>--server</code> both used, serve     datasets from saved Zarrs rather than     computing them on the fly.</li> <li><code>-o</code>, <code>--output</code> DIRECTORY  Write any output data to this directory,     which will be created if it does not exist     already.</li> <li><code>-k</code>, <code>--keep</code>: Keep container after it has finished     running.</li> <li><code>-b</code>, <code>--open-browser</code>: After the server has started, open a web browser     window showing the viewer. Implies <code>--server</code>.</li> <li><code>--help</code>: Show a help message for this subcommand and exit.</li> </ul> <p>This subcommand runs an xcengine container image. Any arguments provided after IMAGE will be passed on to the command executed inside the container. An image can also be run using the <code>docker run</code> command, but <code>xcetool image run</code> provides some additional convenience (e.g. easy configuration of a server HTTP port).</p> <p>If you use the <code>--server</code> option with <code>xcetool image run</code>, the image will be run in xcube server mode: after the code from the input notebook is used to generate datasets, those datasets will be made available in an xcube server instance. You can also use the <code>--port</code> option to select the HTTP port where the xcube server should be exposed. The server also includes an interactive web viewer component. On start-up, <code>xcetool</code> will print the URLs of the xcube server and viewer to the standard output.</p> <p>If you give the <code>--server</code> or <code>--port</code> options, <code>xcetool</code> will run the container indefinitely as an xcube server and viewer instance. You can stop the container and force <code>xcetool</code> to exit by pressing ctrl-C on the command line (or by sending it an interrupt signal in some other way).</p>"},{"location":"xcetool/#xcetool-make-script","title":"<code>xcetool make-script</code>","text":"<p>This subcommand does not generate a container image, but a directory containing the main contents that the image would have had: a script derived from the notebook along with some supporting files. The <code>make-script</code> subcommand is mainly useful for debugging.</p> <p>Usage: <code>xcetool make-script [OPTIONS] NOTEBOOK OUTPUT_DIR</code></p> <p>Create a compute engine script on the host system. The output directory will be used for the generated script, supporting code modules, and any output produced by running the script.</p> <p>Options:</p> <ul> <li><code>-b</code>, <code>--batch</code>: Run as batch script after creating</li> <li><code>-s</code>, <code>--server</code>: Run the script as an xcube server after creating it.</li> <li><code>-f</code>, <code>--from-saved</code>: If <code>--batch</code> and <code>--server</code> both used, serve datasets from saved Zarrs rather than computing them on the fly.</li> <li><code>-c</code>, <code>--clear</code>: Clear output directory before writing to it</li> <li><code>--help</code>: Show a help message for this subcommand and exit.</li> </ul>"},{"location":"xcetool/#publishing-your-container-image","title":"Publishing your container image","text":"<p>Once you have built your container image locally, you can push it to an online registry. The tag is used to determine the registry and repository to which to push the image. For example, if an image is tagged <code>quay.io/alice/helloworld:1.0</code>, pushing it will attempt to upload the image to the repository <code>helloworld</code> under the account <code>alice</code> on the registry <code>quay.io</code>. See the Docker documentation for more details.</p>"}]}