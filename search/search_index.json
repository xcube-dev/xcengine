{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"xcengine","text":"<p>xcengine turns Python Jupyter notebooks into:</p> <ul> <li>OGC Earth Observation Application   Packages</li> <li>Run-anywhere Docker images that bundle datasets with an   xcube server/viewer deployment   for easy interfacing and visualization</li> </ul> <p>Earth Observation Application Packages can be complex to implement correctly. The process can't be completely automated, but xcengine tries to simplify it as much as possible for Jupyter Notebook authors using code analysis and sensible defaults.</p> <p>This documentation provides instructions for installing and using xcengine and links to further resources.</p> <ol> <li>Introduction</li> <li>Installing xcengine</li> <li>Making a Jupyter notebook xcengine-compatible</li> <li>Running <code>xcetool</code></li> <li>Testing and running Application Packages</li> <li>Further documentation and resources</li> </ol> <p>xcengine is developed as part of the Open Earth Monitor Cyberinfrastructure project, which has received funding from the European Union's Horizon Europe research and innovation programme under grant agreement No. 101059548.</p>"},{"location":"installing/","title":"Installing xcengine","text":"<p>xcengine is developed on GitHub and distributed as a Conda package on the conda-forge channel.</p>"},{"location":"installing/#installing-from-conda-forge","title":"Installing from conda-forge","text":"<p>Using mamba, conda, or any other conda-compatible package manager, you can install xcengine into the current environment with a command like</p> <pre><code>mamba install -c conda-forge xcengine\n</code></pre> <p>You can create a new environment containing xcengine with a command like</p> <pre><code>mamba create -c conda-forge xcengine\n</code></pre>"},{"location":"installing/#installing-directly-from-the-github-repository","title":"Installing directly from the GitHub repository","text":"<p>If you want to work with the latest, unreleased development version of xcengine, you can install it from the GitHub repository.</p> <p>First, clone the repository and change to its root directory:</p> <pre><code>git clone https://github.com/xcube-dev/xcengine.git\ncd xcengine\n</code></pre> <p>Next, create a conda environment containing the dependencies and activate it:</p> <pre><code>mamba env create -f environment.yml\nmamba activate xcengine\n</code></pre> <p>Finally, install xcengine itself from the repository using pip:</p> <pre><code>pip install --no-deps --editable .\n</code></pre>"},{"location":"intro/","title":"Introduction","text":"<p>xcengine turns Python Jupyter notebooks into Earth Observation Application Packages and Docker images bundling an xcube Server and Viewer.</p>"},{"location":"intro/#jupyter-notebooks","title":"Jupyter notebooks","text":"<p>Jupyter notebooks provide a web-based interactive development environment which integrates code, documentation, and output visualization.</p>"},{"location":"intro/#application-packages","title":"Application packages","text":"<p>The Earth Observation Application Package is an increasingly popular format for packaging and deploying EO software tools. It is defined in a Best Practice document published by the Open Geospatial Consortium. An Application Package consists of two parts:</p> <ol> <li>A Docker container     image    containing the processing code to be packaged.</li> <li>A Common Workflow Language (CWL) file    which defines how the code in the container image should be run,    and what its available parameters, inputs, and outputs are.</li> </ol> <p>Application Packages are designed to be run on cloud processing platforms, but can also be tested locally. Application Packages provide a great deal of power and flexibility; partly because of this flexibility, they can be complex and challenging to build from scratch.</p>"},{"location":"intro/#xcube-server-and-viewer","title":"xcube Server and Viewer","text":"<p>xcube is a mature and powerful Python framework for EO data processing and visualization. Amongst other features, it includes an API server and web viewer which can serve and visualize data from a wide variety of sources, both statically stored and fetched or processed on demand.</p>"},{"location":"intro/#xcengine","title":"xcengine","text":"<p>xcengine takes Python Jupyter notebooks as input, and produces a Docker image and a CWL file which encapsulate the code contained in the notebook. Together these constitute an Application Package. The Docker image can also be run in an interactive, stand-alone mode to start up an xcube API server and web viewer, allowing the notebook's data to be exported via a variety of standard interfaces or explored visually and interactively.</p>"},{"location":"notebook/","title":"Making a Jupyter notebook xcengine-compatible","text":"<p>xcengine is designed to require as little alteration as possible to a Python notebook, but some configuration may be necessary, in particular to define input parameters.</p>"},{"location":"notebook/#configuring-input-parameters","title":"Configuring input parameters","text":"<p>An Application Package can have, and usually does have, input parameters defined types and default values, which can be set by the caller when running the package. xcengine automatically generates these parameters from variables in the notebook. Any variable to be used as a parameter must be defined in the parameters cell of the notebook. You can only have one parameters cell in a notebook, and it is strongly advised that the parameters cell appear as early as possible in the notebook.</p> <p>You turn a normal code cell into a parameters cell by adding a tag called parameters to it in Jupyter Lab using the Property Inspector. (The Property Inspector can be opened by clicking the gear icon at the top right of the Jupyter Lab window.)</p> <p></p> <p>You can define as many parameters as you like in the property cell. The values you assign to them will be used as the default values for these parameters when xcengine generates the Application Package.</p> <p>This tagging convention is similar to the one used by papermill.</p>"},{"location":"notebook/#configuring-xcengine","title":"Configuring xcengine","text":"<p>As well as parameters, the parameters cell can contain an xcengine configuration dictionary. This is a Python dictionary with the special name <code>xcengine_config</code>. Available configuration settings are:</p> <ul> <li><code>workflow_id</code>: a string identifier for the workflow in your Application     Package. The runner or Application Package platform can use this     identifier to refer to you Application Package. By default, the name     of the notebook (without the <code>.ipynb</code> suffix) is used.</li> <li><code>environment_file</code>: the name of a YAML file defining a conda     environment     (these are often called <code>environment.yml</code>). If an environment file is not     specified in the notebook or on the command line, xcetool will try to     deduce the environment automatically. This cannot be done 100% reliably,     so it is strongly recommended to provide an environment file.</li> <li><code>container_image_tag</code>: the tag applied to the Docker container image that     xcengine builds. If you plan to push the image to a public registry,     you can enter the final registry tag here and push the image once it's     been built by xcengine. If no tag is specified, xcengine will create one     based on the current date and time.</li> </ul> <p>Some of these configuration settings can also be set on the command line.</p>"},{"location":"notebook/#dataset-output","title":"Dataset output","text":""},{"location":"notebook/#selecting-datasets-for-output","title":"Selecting datasets for output","text":"<p>No additional code or configuration is needed for datasets to be written from Application Packages or served when the container image is run in xcube Server/Viewer mode. xcengine will automatically output or serve any instance of <code>xarray.DataSet</code> which is in scope when the notebook's code has finished executing. If you're created some datasets which you don't wish to be written, you can use the Python <code>del</code> statement to delete them at the end of the notebook to remove them, e.g.</p> <pre><code>del my_temporary_dataset\n</code></pre>"},{"location":"notebook/#setting-dataset-output-type","title":"Setting dataset output type","text":"<p>By default, all <code>xarray.DataSet</code> instances are written as Zarr. But you can force them to be written as NetCDF by setting an attribute on the dataset, like this:</p> <pre><code>my_dataset.attrs[\"xcengine_output_format\"] = \"netcdf\"\n</code></pre>"},{"location":"resources/","title":"Further documentation and resources","text":"<p>xcengine has been presented at several conferences and workshops. Most of the presentation materials are available online and provide a useful complement to this documentation.</p> <p>Presentation at OEMC Global Workshop 2024, Laxenburg. Pontus Lurcock, \"Large-scale EO processing with xcube on CDSE\".  Video recording of presentation.</p> <p>Presentation at ESA Living Planet Symposium 2025, Vienna. Pontus Lurcock, Tejas Morbagal Harish, and Alicja Balfanz, \"From notebooks to application packages with xcube and xcengine\". Slide deck.</p> <p>Tutorial at OpenGeoHub EO-Council Summer School 2025, Wageningen: \"Application packages in the xcube ecosystem\". Course page with links to slides, documentation, and hands-on exercises. Video recording of presentation.</p> <p>ESA Big Data from Space 2025, Riga. Yogesh Baljeet Singh, Norman Fomferra, Pontus Lurcock, Gunnar Brandt and Tejas Morbagal Harish: \"From reproducible EO Workflow development to OGC Application Packages for Scalable Data Cube Generation and Visualisation\". Programme entry.</p>"},{"location":"testing/","title":"Testing and running Application Packages","text":"<p>Application Packages are generally deployed to cloud platforms, but there are also ways to run CWL files and complete Application Packages locally.</p>"},{"location":"testing/#running-with-cwltool","title":"Running with cwltool","text":"<p>cwltool is the reference runner for CWL files. It doesn't implement the full Application Package best practice (so there is no stage-in / stage-out functionality) but can nevertheless be used to run CWL files that implement Application Packages.</p>"},{"location":"testing/#running-with-zoo-project-and-the-dru-extensions","title":"Running with ZOO-Project and the DRU extensions","text":"<p>For a fully functional, locally deployable Application Package platform you can use the ZOO-Project with the optional DRU extensions, running on minikube. The EOEPCA+ documentation gives detailed instructions for installation.</p>"},{"location":"xcetool/","title":"Running xcengine","text":""},{"location":"xcetool/#the-xcetool-command","title":"The <code>xcetool</code> command","text":"<p>The command-line interface to xcengine is the command <code>xcetool</code>, which implements multiple subcommands and options for building and running container images and Application Packages.</p> <p>You can use the <code>--help</code> flag for any <code>xcetool</code> command or subcommand to get more details on usage and available options.</p>"},{"location":"xcetool/#xcetool-image-build","title":"<code>xcetool image build</code>","text":"<p>This is the main <code>xcetool</code> subcommand: it builds a container image from a supplied notebook and environment file. If given the <code>--eoap</code> argument, it also generates a CWL file defining a corresponding application package.</p>"},{"location":"xcetool/#xcetool-image-run","title":"<code>xcetool image run</code>","text":"<p>This subcommand runs an xcengine container image. An image can also be run using the <code>docker run</code> command, but <code>xcetool image run</code> provides some additional convenience (e.g. easy configuration of the HTTP port).</p>"},{"location":"xcetool/#xcetool-make-script","title":"<code>xcetool make-script</code>","text":"<p>This subcommand does not generate a container image, but a directory containing the main contents that the image would have had: a script derived from the notebook along with some supporting files. The <code>make-script</code> subcommand is mainly useful for debugging.</p>"},{"location":"xcetool/#publishing-your-container-image","title":"Publishing your container image","text":"<p>Once you have built your container image locally, you can push it to an online registry. The tag is used to determine the registry and repository to which to push the image. For example, if an image is tagged <code>quay.io/alice/helloworld:1.0</code>, pushing it will attempt to upload the image to the repository <code>helloworld</code> under the account <code>alice</code> on the registry <code>quay.io</code>.</p>"},{"location":"xcetool/#deploying-your-application-package","title":"Deploying your Application Package","text":"<p>Once your container image has been pushed to a registry, the CWL file can be deployed to a cloud platform to make your Application Package available to users of this platform. The process for deploying the CWL file varies; consult the platform documentation or support for details.</p>"}]}